#if RAM_UDC_DISK
#include <mass_storage.h>
#include <libc.h>
#include <dlmalloc.h>
#include "ccc.h"

#define BLOCKNUM        (4*1024)
//#define BLOCKNUM        (40*1024)
#define SECTSIZE        512

#define PACKAGE_LEN     1032
#define MAX_SIZE        (SECTSIZE*3)

#if 1	
#define start_sector_dummy 64
#else
#define start_sector_dummy 33 //cn 2009-03-20
#endif

#define start_sector_readme_txt (start_sector_dummy + 3)
#define start_sector_setup_exe 	(start_sector_readme_txt +10)

typedef struct _COMM {
	unsigned char disk_receive_data[MAX_SIZE];
	unsigned char disk_send_data[MAX_SIZE];
//	unsigned char *disk_receive_data;
//	unsigned char *disk_send_data;
	unsigned char DataReceived;
	unsigned char DataSent;
	int sizesent;
	int sizereceived;
}GCC_PACKED TCOMM;

typedef struct _USBHeader_ {
        unsigned char  HeaderTag[2];
        unsigned char  Cmd;
        unsigned char  CmdCheck;
        unsigned short Len;
        unsigned short CheckSum;
}GCC_PACKED USBHeader, *PUSBHeader;

static TCOMM comm;
//extern unsigned char udc_prio;

static UDC_LUN udcLun;
static unsigned char disk_dbr[512]={
0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30, 0x00, 0x02, 0x01, 0x08, 0x00,
#if 1
0x02, 0x00, 0x02, 0x00, 0x10, 0xF8, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
#else //cn 2009-03-20
0x02, 0x10, 0x00, 0x00, 0x10, 0xF8, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
#endif
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x36, 0xDF, 0x58, 0x9C, 0x4E, 0x4F, 0x20, 0x4E, 0x41,
0x4D, 0x45, 0x20, 0x20, 0x20, 0x20, 0x46, 0x41, 0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x33, 0xC9,
0x8E, 0xD1, 0xBC, 0xF0, 0x7B, 0x8E, 0xD9, 0xB8, 0x00, 0x20, 0x8E, 0xC0, 0xFC, 0xBD, 0x00, 0x7C,
0x38, 0x4E, 0x24, 0x7D, 0x24, 0x8B, 0xC1, 0x99, 0xE8, 0x3C, 0x01, 0x72, 0x1C, 0x83, 0xEB, 0x3A,
0x66, 0xA1, 0x1C, 0x7C, 0x26, 0x66, 0x3B, 0x07, 0x26, 0x8A, 0x57, 0xFC, 0x75, 0x06, 0x80, 0xCA,
0x02, 0x88, 0x56, 0x02, 0x80, 0xC3, 0x10, 0x73, 0xEB, 0x33, 0xC9, 0x8A, 0x46, 0x10, 0x98, 0xF7,
0x66, 0x16, 0x03, 0x46, 0x1C, 0x13, 0x56, 0x1E, 0x03, 0x46, 0x0E, 0x13, 0xD1, 0x8B, 0x76, 0x11,
0x60, 0x89, 0x46, 0xFC, 0x89, 0x56, 0xFE, 0xB8, 0x20, 0x00, 0xF7, 0xE6, 0x8B, 0x5E, 0x0B, 0x03,
0xC3, 0x48, 0xF7, 0xF3, 0x01, 0x46, 0xFC, 0x11, 0x4E, 0xFE, 0x61, 0xBF, 0x00, 0x00, 0xE8, 0xE6,
0x00, 0x72, 0x39, 0x26, 0x38, 0x2D, 0x74, 0x17, 0x60, 0xB1, 0x0B, 0xBE, 0xA1, 0x7D, 0xF3, 0xA6,
0x61, 0x74, 0x32, 0x4E, 0x74, 0x09, 0x83, 0xC7, 0x20, 0x3B, 0xFB, 0x72, 0xE6, 0xEB, 0xDC, 0xA0,
0xFB, 0x7D, 0xB4, 0x7D, 0x8B, 0xF0, 0xAC, 0x98, 0x40, 0x74, 0x0C, 0x48, 0x74, 0x13, 0xB4, 0x0E,
0xBB, 0x07, 0x00, 0xCD, 0x10, 0xEB, 0xEF, 0xA0, 0xFD, 0x7D, 0xEB, 0xE6, 0xA0, 0xFC, 0x7D, 0xEB,
0xE1, 0xCD, 0x16, 0xCD, 0x19, 0x26, 0x8B, 0x55, 0x1A, 0x52, 0xB0, 0x01, 0xBB, 0x00, 0x00, 0xE8,
0x3B, 0x00, 0x72, 0xE8, 0x5B, 0x8A, 0x56, 0x24, 0xBE, 0x0B, 0x7C, 0x8B, 0xFC, 0xC7, 0x46, 0xF0,
0x3D, 0x7D, 0xC7, 0x46, 0xF4, 0x29, 0x7D, 0x8C, 0xD9, 0x89, 0x4E, 0xF2, 0x89, 0x4E, 0xF6, 0xC6,
0x06, 0x96, 0x7D, 0xCB, 0xEA, 0x03, 0x00, 0x00, 0x20, 0x0F, 0xB6, 0xC8, 0x66, 0x8B, 0x46, 0xF8,
0x66, 0x03, 0x46, 0x1C, 0x66, 0x8B, 0xD0, 0x66, 0xC1, 0xEA, 0x10, 0xEB, 0x5E, 0x0F, 0xB6, 0xC8,
0x4A, 0x4A, 0x8A, 0x46, 0x0D, 0x32, 0xE4, 0xF7, 0xE2, 0x03, 0x46, 0xFC, 0x13, 0x56, 0xFE, 0xEB,
0x4A, 0x52, 0x50, 0x06, 0x53, 0x6A, 0x01, 0x6A, 0x10, 0x91, 0x8B, 0x46, 0x18, 0x96, 0x92, 0x33,
0xD2, 0xF7, 0xF6, 0x91, 0xF7, 0xF6, 0x42, 0x87, 0xCA, 0xF7, 0x76, 0x1A, 0x8A, 0xF2, 0x8A, 0xE8,
0xC0, 0xCC, 0x02, 0x0A, 0xCC, 0xB8, 0x01, 0x02, 0x80, 0x7E, 0x02, 0x0E, 0x75, 0x04, 0xB4, 0x42,
0x8B, 0xF4, 0x8A, 0x56, 0x24, 0xCD, 0x13, 0x61, 0x61, 0x72, 0x0B, 0x40, 0x75, 0x01, 0x42, 0x03,
0x5E, 0x0B, 0x49, 0x75, 0x06, 0xF8, 0xC3, 0x41, 0xBB, 0x00, 0x00, 0x60, 0x66, 0x6A, 0x00, 0xEB,
0xB0, 0x4E, 0x54, 0x4C, 0x44, 0x52, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A, 0x52, 0x65,
0x6D, 0x6F, 0x76, 0x65, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x6F, 0x74,
0x68, 0x65, 0x72, 0x20, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x2E, 0xFF, 0x0D, 0x0A, 0x44, 0x69, 0x73,
0x6B, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xFF, 0x0D, 0x0A, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20,
0x61, 0x6E, 0x79, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x73, 0x74, 0x61,
0x72, 0x74, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0xCB, 0xD8, 0x55, 0xAA
};

#if 0
static unsigned char disk_sec_32[]={
0x4F, 0x50, 0x54, 0x49, 0x4F, 0x4E, 0x53, 0x20, 0x43, 0x46, 0x47, 0x20, 0x18, 0x8B, 0x6E, 0xA8,
0x7A, 0x39, 0x7A, 0x39, 0x00, 0x00, 0x4C, 0xA8, 0x7A, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x54, 0x45, 0x4D, 0x50, 0x4C, 0x41, 0x54, 0x45, 0x44, 0x41, 0x54, 0x20, 0x18, 0x96, 0x75, 0xA8,
0x7A, 0x39, 0x7A, 0x39, 0x00, 0x00, 0x38, 0xA8, 0x7A, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x55, 0x53, 0x45, 0x52, 0x20, 0x20, 0x20, 0x20, 0x44, 0x41, 0x54, 0x20, 0x18, 0x99, 0x7C, 0xA8,
0x7A, 0x39, 0x7A, 0x39, 0x00, 0x00, 0x43, 0xA8, 0x7A, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x41, 0x54, 0x54, 0x4C, 0x4F, 0x47, 0x20, 0x20, 0x44, 0x41, 0x54, 0x20, 0x18, 0x92, 0x85, 0xA8,
0x7A, 0x39, 0x7A, 0x39, 0x00, 0x00, 0x01, 0xA8, 0x7A, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#endif

static unsigned char disk_fat[BLOCKNUM];
unsigned char disk_fdt[512];
//add by cn 2009-03-22
//extern unsigned char UDCDataReceived;


unsigned int sendtousb(unsigned char *buf,unsigned short size)
{
	PUSBHeader usbhr = (PUSBHeader)comm.disk_send_data;

	if(comm.DataSent>0)
	{
		memset(comm.disk_send_data, 0, MAX_SIZE);
		memcpy(comm.disk_send_data + sizeof(USBHeader), buf,size);
		usbhr->Len = size;
		*(comm.disk_send_data + sizeof(USBHeader)+usbhr->Len)=0xFF;
		comm.DataSent = 0;
//		printf("<<<<<<<<<<< firmware sending data %x  %x  %x %x %x %x %x %x %x %x. data len:%d\n",
//			buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6],buf[7],buf[8],buf[9],usbhr->Len);
		return usbhr->Len;
	}
	printf("firmware send failed\n"); 
	return 0;
}

unsigned int recvfromusb(unsigned char *buf, unsigned short size)
{
        PUSBHeader usbhr = (PUSBHeader)comm.disk_receive_data;

//add by cn 2009-03-22
#if 0
	if( (comm.DataReceived>0) && *(comm.disk_receive_data + sizeof(USBHeader)+usbhr->Len)==0xFF )
	{
		memcpy(buf,comm.disk_receive_data + sizeof(USBHeader), usbhr->Len);
		comm.DataReceived = 0;
		
	//	printf("<<<<<<<<<<< firmware reading data %x  %x  %x %x %x %x %x %x %x %x. data len:%d\n",
	//		buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6],buf[7],buf[8],buf[9],usbhr->Len);
		if(usbhr->Len<=size)
			return usbhr->Len;
	}

#else
	if( comm.DataReceived>0) 
        {
		if(*(comm.disk_receive_data + sizeof(USBHeader)+usbhr->Len)==0xFF )
		{
	                memcpy(buf,comm.disk_receive_data + sizeof(USBHeader), usbhr->Len);
			
	//	printf("ddd ReadFormusb() ok\n\n");
		}
		else
			memset(buf,0,16);

                comm.DataReceived = 0;
	//	UDCDataReceived=0;
                return usbhr->Len;
	}
#endif

	return 0;
}

int initVFEntry(unsigned char *fat, unsigned char *fdt);

static unsigned int InitDev(unsigned int handle)
{
	printf("Ram Disk Mount\r\n");
//	disk = (unsigned char *)((unsigned int)disk_emu | 0xa0000000);
	/*
	comm.disk_receive_data = (unsigned char *)malloc(SECTSIZE*3);
	comm.disk_send_data = (unsigned char *)malloc(SECTSIZE*3);
	if(comm.disk_receive_data==0 || comm.disk_send_data==0)
	{
		printf("malloc memory for communication failed\n");
		return -1;
	} */
	comm.DataReceived = 0;
	comm.DataSent = 1;
	//add by cn 2009-03-22
//	UDCDataReceived=0;

//	disk_dbr[19]=(BLOCKNUM>>8)&0xFF; 
//	disk_dbr[20]=BLOCKNUM&0xFF; 
	initVFEntry(disk_fat, disk_fdt);
	return 0;
}

int readVFile(unsigned char *buffer, int cluster, int count);
static unsigned int ReadDevSector(unsigned int handle,unsigned char *buf,unsigned int startsect,unsigned int sectcount)
{
//	printf("PC  read dev = buf:%p, s:%d c:%d\r\n",buf, startsect,sectcount);
#if 1
	PUSBHeader usbhr = (PUSBHeader)comm.disk_send_data;

	memset(buf, 0, sectcount*SECTSIZE);

	if(startsect==0)
		memcpy(buf, disk_dbr, sizeof(disk_dbr));
	else if(startsect==32)
		memcpy(buf, disk_fdt, sizeof(disk_fdt));
	else if(startsect==8 || startsect==20)
		memcpy(buf, disk_fat, sizeof(disk_fat));
	else if(startsect>=start_sector_readme_txt)
	{
		readVFile(buf, startsect, sectcount);
	//	printf("PC read file.\n");
	} 
#endif
#if 1
	else if(startsect>=start_sector_dummy && startsect<start_sector_dummy+3)
	{
	#if 0  //add by cn 2009-03-22
		if(usbhr->Len<=0)
		{
		//	memset(buf, 0, sectcount*SECTSIZE);
			return 0;
		}
	#endif
		if(sectcount>3)
			sectcount = 3;
		/* comm.DataSent ==0 mean there is new data can be read */
		if(!comm.DataSent)
		{
		//	memcpy(buf,(void *)comm.disk_send_data, sectcount*SECTSIZE);
			memcpy(buf,comm.disk_send_data + (startsect - start_sector_dummy)*SECTSIZE, 
										sectcount*SECTSIZE);
		/*	printf("<<<<<<<<<<< PC reading data %x  %x  %x %x %x %x %x %x %x %x. data len: %d\n",
			buf[8],buf[9],buf[10],buf[11],buf[12],buf[13],buf[14],buf[15],buf[16],buf[17],
			*(unsigned short *)(buf+4)); */
		//	printf("<<<<<<<<<<< PC reading data %x  %x  Len:%d\n",buf[4],buf[5],*(unsigned short *)(buf+4));
			comm.sizesent = (startsect - start_sector_dummy)*SECTSIZE + sectcount*SECTSIZE;
			
			/* if the data that have been sent  larger than valid data length, mark the DataSent flag to be 1 */
		//	if( comm.sizesent>=usbhr->Len)
			//add by cn 2009-03-22
			if(startsect == start_sector_dummy && *(comm.disk_send_data + sizeof(USBHeader)+usbhr->Len)==0xFF )
			{
				comm.DataSent = 1;
			}
			return 1;

		//	printf("PC read: the valid data len: %d, the sent data len:%d, buf[4]:%x, buf[5]:%x\n",
		//		usbhr->Len,comm.sizesent,buf[4],buf[5]);
		}
		else	
			return 0;
	//		memset(buf, 0, sectcount*SECTSIZE);
	}
#endif
	return 1;
}

static unsigned int WriteDevSector(unsigned int handle,unsigned char *buf,unsigned int startsect,unsigned int sectcount)
{
//	printf("PC write dev = buf:%p, s:%d c:%d\r\n",buf,startsect,sectcount);
//	DumpData(buf,sectcount*SECTSIZE);
/*	
	if(startsect==32)
                memcpy(disk_fdt, buf,  sizeof(disk_fdt));
        else if(startsect==8 || startsect==20)
                memcpy(disk_fat, buf,  sizeof(disk_fat));
	else if(startsect>=64)
		writeVFile(buf, startsect, sectcount);
//	memcpy((void *)(disk + startsect * SECTSIZE),buf,sectcount*SECTSIZE);
*/
#if 1
	PUSBHeader usbhr = (PUSBHeader)buf;
	if(startsect>=start_sector_dummy && startsect<start_sector_dummy+3)
	{
		if(usbhr->Len<=0)
			return 0;

		if(sectcount>3)
			sectcount = 3;
		/* comm.DataReceived == 0 mean the received data have been processed */
		if(!comm.DataReceived)
		{
			memset(comm.disk_receive_data, 0 ,MAX_SIZE);
		//	memcpy((void *)comm.disk_receive_data, buf,sectcount*SECTSIZE);
			memcpy(comm.disk_receive_data + (startsect - start_sector_dummy)*SECTSIZE, 
				buf,sectcount*SECTSIZE);
			comm.sizereceived = (startsect - start_sector_dummy)*SECTSIZE + sectcount*SECTSIZE;
			//add by cn 2009-03-22
			if((startsect == start_sector_dummy)&&*(comm.disk_receive_data + sizeof(USBHeader)+usbhr->Len)==0xFF )
			{
				comm.DataReceived = 1;
				//UDCDataReceived=1;
				memset(comm.disk_send_data,0,MAX_SIZE);
			}
			return 1;
			//if( comm.sizereceived >= usbhr->Len)
			//	comm.DataReceived = 1;
/*			printf("PC wirte: valid data len: %d, received data len:%d Flag(0xFF):%x\n",
			usbhr->Len,comm.sizereceived,comm.disk_receive_data[sizeof(USBHeader)+usbhr->Len]);
			printf(">>>>>>>>>> PC writing data %x %x %x %x %x %x %x %x %x %x. data len:%d\n",
			buf[8],buf[9],buf[10],buf[11],buf[12],buf[13],buf[14],buf[15],buf[16],buf[17],
			(unsigned short)buf[4]); */
		}
		else
			return 0;
	}
#endif
	return 1;
}

static unsigned int CheckDevState(unsigned int handle)
{
	return 1;
}

static unsigned int GetDevInfo(unsigned int handle,PDEVINFO pinfo)
{
	pinfo->hiddennum = 0;
	pinfo->headnum = 2;
	pinfo->sectnum = 4;
	pinfo->partsize = BLOCKNUM;
	pinfo->sectorsize = 512;
	return 0;
}

static unsigned int  DeinitDev(unsigned handle)
{
//	free(comm.disk_receive_data);
//	free(comm.disk_send_data);
	return 0;
}

void Init_Mass_Storage();
unsigned int RegisterDev(PUDC_LUN pdev);
void InitUdcRam()
{

	printf("InitUdcRam\r\n");
	
	Init_Mass_Storage();
	udcLun.InitDev = InitDev;
	udcLun.ReadDevSector = ReadDevSector;
	udcLun.WriteDevSector = WriteDevSector;
	udcLun.CheckDevState = CheckDevState;
	udcLun.GetDevInfo = GetDevInfo;
	udcLun.DeinitDev = DeinitDev;
	udcLun.DevName = (unsigned int)'RAM1';

	if(RegisterDev(&udcLun))
		printf("UDC Register Fail!!!\r\n");
	printf("InitUdcRam finish = %08x\r\n",&udcLun);
	
}
#endif
